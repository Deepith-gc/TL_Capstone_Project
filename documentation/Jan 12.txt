What This Project Demonstrates (Non-Technical Explanation)
This project demonstrates how modern computer networks can be centrally controlled and intelligently managed, instead of relying on fixed, hard-coded behavior inside network devices.

In a traditional network, switches and routers make decisions on their own.
In this project, all decisions are made by a central controller, and the network devices simply follow instructions. This approach is called Software-Defined Networking (SDN).

What the Candidate Is Showing

Centralized Control of the Network
The candidate demonstrates that network behavior can be controlled from a single software program rather than configuring each device individually.

Separation of Responsibilities
The network is split into:

A decision-making component (the controller)

A traffic-forwarding component (the switches)

This mirrors how large telecom and enterprise networks are designed today.

Dynamic Network Behavior
Instead of fixed rules, the network learns how devices communicate and adapts automatically when traffic flows for the first time.

Policy-Driven Operation
The system shows that traffic is handled based on rules and policies, not manual intervention. This is the foundation of intelligent traffic management.

Reliability and Correctness
The project proves that traffic reaches its destination consistently and efficiently after the controller programs the network.

Industry-Relevant Skills
The lab uses the same architectural concepts applied in:

Telecom core networks

Cloud data centers

5G transport systems

Network automation platforms

Why This Matters to the Company

Reduces manual configuration effort

Enables scalable and programmable networks

Supports future technologies like 5G and cloud infrastructure

Demonstrates structured problem-solving and system thinking

One-Line Summary (For Resume or HR Review)

“This project demonstrates centralized, software-controlled network management where traffic behavior is dynamically decided by policy rather than fixed device configuration.”

















=====================================================================
LAB GUIDE
SDN-Based Traffic Steering Using Open vSwitch and Ryu Controller
=====================================================================

Objective
---------
To design, implement, and validate an SDN-based traffic steering system
using Open vSwitch as the data plane and a Ryu controller as the control
plane. The controller dynamically manages forwarding behavior using
OpenFlow, demonstrating separation of control and data planes.

---------------------------------------------------------------------
LAB ENVIRONMENT
---------------------------------------------------------------------

Platform:
- Mininet Official VM (Ubuntu-based)

Software Components:
- Mininet
- Open vSwitch (OVS)
- Ryu SDN Controller
- OpenFlow Version 1.3
- Python 3

---------------------------------------------------------------------
NETWORK TOPOLOGY
---------------------------------------------------------------------

Logical Topology:

    h1 ----\
            s1 ---- s2 ---- h3
    h2 ----/

IP Addressing:
- h1: 10.0.0.1/24
- h2: 10.0.0.2/24
- h3: 10.0.0.3/24

---------------------------------------------------------------------
PROJECT DIRECTORY STRUCTURE
---------------------------------------------------------------------

/home/mininet/sdn-traffic-steering/
├── controller/
│   └── traffic_steering.py
├── topology/
│   └── custom_topo.py
└── logs/

---------------------------------------------------------------------
STEP 1: PROJECT SETUP
---------------------------------------------------------------------

1. Login to Mininet VM
   User: mininet
   Home directory: /home/mininet

2. Create project directory
   $ cd /home/mininet
   $ mkdir sdn-traffic-steering
   $ cd sdn-traffic-steering

3. Create subdirectories
   $ mkdir controller topology logs

---------------------------------------------------------------------
STEP 2: INSTALL RYU CONTROLLER
---------------------------------------------------------------------

$ sudo apt update
$ sudo apt install -y ryu-manager

Verify installation:
$ ryu-manager --version

---------------------------------------------------------------------
STEP 3: CREATE CUSTOM MININET TOPOLOGY
---------------------------------------------------------------------

File Path:
 /home/mininet/sdn-traffic-steering/topology/custom_topo.py

File Content:

from mininet.topo import Topo

class TrafficSteeringTopo(Topo):
    def build(self):

        h1 = self.addHost('h1', ip='10.0.0.1/24')
        h2 = self.addHost('h2', ip='10.0.0.2/24')
        h3 = self.addHost('h3', ip='10.0.0.3/24')

        s1 = self.addSwitch('s1')
        s2 = self.addSwitch('s2')

        self.addLink(h1, s1)
        self.addLink(h2, s1)
        self.addLink(s1, s2)
        self.addLink(s2, h3)

topos = {
    'steering': TrafficSteeringTopo
}

---------------------------------------------------------------------
STEP 4: IMPLEMENT RYU CONTROLLER
---------------------------------------------------------------------

File Path:
 /home/mininet/sdn-traffic-steering/controller/traffic_steering.py

File Content:

from ryu.base import app_manager
from ryu.controller import ofp_event
from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER
from ryu.controller.handler import set_ev_cls
from ryu.ofproto import ofproto_v1_3
from ryu.lib.packet import packet, ethernet, arp

class TrafficSteeringController(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]

    def __init__(self, *args, **kwargs):
        super(TrafficSteeringController, self).__init__(*args, **kwargs)
        self.mac_to_port = {}

    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        datapath = ev.msg.datapath
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser

        match = parser.OFPMatch()
        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,
                                          ofproto.OFPCML_NO_BUFFER)]
        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS,
                                             actions)]

        mod = parser.OFPFlowMod(datapath=datapath,
                                priority=0,
                                match=match,
                                instructions=inst)
        datapath.send_msg(mod)

    @set_ev_cls(ofp_event.EventOFPPacketIn, MAIN_DISPATCHER)
    def packet_in_handler(self, ev):
        msg = ev.msg
        datapath = msg.datapath
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        in_port = msg.match['in_port']

        pkt = packet.Packet(msg.data)
        eth = pkt.get_protocol(ethernet.ethernet)

        dpid = datapath.id
        self.mac_to_port.setdefault(dpid, {})
        self.mac_to_port[dpid][eth.src] = in_port

        if eth.ethertype == 0x0806:  # ARP
            out_port = ofproto.OFPP_FLOOD
        else:
            if eth.dst in self.mac_to_port[dpid]:
                out_port = self.mac_to_port[dpid][eth.dst]
            else:
                out_port = ofproto.OFPP_FLOOD

        actions = [parser.OFPActionOutput(out_port)]

        if out_port != ofproto.OFPP_FLOOD:
            match = parser.OFPMatch(in_port=in_port, eth_dst=eth.dst)
            inst = [parser.OFPInstructionActions(
                ofproto.OFPIT_APPLY_ACTIONS, actions)]
            mod = parser.OFPFlowMod(datapath=datapath,
                                    priority=10,
                                    match=match,
                                    instructions=inst)
            datapath.send_msg(mod)

        data = None
        if msg.buffer_id == ofproto.OFP_NO_BUFFER:
            data = msg.data

        out = parser.OFPPacketOut(datapath=datapath,
                                  buffer_id=msg.buffer_id,
                                  in_port=in_port,
                                  actions=actions,
                                  data=data)
        datapath.send_msg(out)

---------------------------------------------------------------------
STEP 5: START CONTROLLER
---------------------------------------------------------------------

$ cd /home/mininet/sdn-traffic-steering/controller
$ ryu-manager traffic_steering.py

Leave this terminal running.

---------------------------------------------------------------------
STEP 6: START MININET TOPOLOGY
---------------------------------------------------------------------

Open a new terminal.

$ cd /home/mininet/sdn-traffic-steering
$ sudo mn --custom topology/custom_topo.py \
          --topo steering \
          --controller remote \
          --switch ovs,protocols=OpenFlow13

---------------------------------------------------------------------
STEP 7: VERIFY CONNECTIVITY
---------------------------------------------------------------------

Inside Mininet CLI:

mininet> h1 ping h3
mininet> h2 ping h3

Expected Result:
- Ping succeeds
- First packet shows higher latency
- Subsequent packets show low latency

---------------------------------------------------------------------
OBSERVATIONS
---------------------------------------------------------------------

1. Initial packet triggers controller involvement.
2. Flow rules are installed in switches.
3. Subsequent packets are forwarded by the data plane.
4. ARP packets are correctly handled.
5. Control and data planes are clearly separated.

---------------------------------------------------------------------
CONCLUSION
---------------------------------------------------------------------

This lab demonstrates:
- SDN architecture using OpenFlow
- Controller-driven forwarding
- Open vSwitch operation
- Deterministic and reproducible SDN behavior
- Correct handling of ARP and ICMP traffic

The implementation satisfies production-grade SDN fundamentals
expected for telecom and networking recruitment evaluations.

=====================================================================
END OF LAB GUIDE
=====================================================================







