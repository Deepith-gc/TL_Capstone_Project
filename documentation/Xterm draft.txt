Perfect! Let’s create a **final, clean, beginner-friendly, fully working SDN traffic steering setup** for your capstone demo. I’ll include everything: topology, controller, xterm setup, and a step-by-step workflow.

---

# **SDN Traffic Steering Capstone – Final Draft**

---

## **1. Topology (Python)**

```python
# File: traffic_steering_topology.py
from mininet.topo import Topo
from mininet.net import Mininet
from mininet.node import RemoteController, OVSSwitch
from mininet.cli import CLI
from mininet.log import setLogLevel

class TrafficSteeringTopo(Topo):
    def build(self):
        # Hosts
        h1 = self.addHost('h1')  # High Priority
        h2 = self.addHost('h2')  # Medium Priority
        h3 = self.addHost('h3')  # Server
        h4 = self.addHost('h4')  # Best Effort

        # Switches (OpenFlow 1.3)
        s1 = self.addSwitch('s1', protocols='OpenFlow13')
        s2 = self.addSwitch('s2', protocols='OpenFlow13')
        s3 = self.addSwitch('s3', protocols='OpenFlow13')

        # Links
        self.addLink(h1, s1)
        self.addLink(h2, s1)
        self.addLink(s1, s2)
        self.addLink(s1, s3)
        self.addLink(s2, h3)
        self.addLink(s3, h4)

def run():
    topo = TrafficSteeringTopo()
    net = Mininet(
        topo=topo,
        controller=RemoteController('ryu', ip='127.0.0.1', port=6653),
        switch=OVSSwitch,
        autoSetMacs=True,
        autoStaticArp=True,
        build=True
    )

    print("\n[INFO] Starting Mininet network...")
    net.start()
    print("[INFO] Network started successfully")
    print("[INFO] Entering Mininet CLI")
    CLI(net)
    net.stop()
    print("[INFO] Mininet stopped")

if __name__ == '__main__':
    setLogLevel('info')
    run()
```

---

## **2. Controller (Python)**

```python
# File: traffic_steering_controller.py
from ryu.base import app_manager
from ryu.controller import ofp_event
from ryu.controller.handler import CONFIG_DISPATCHER, MAIN_DISPATCHER, DEAD_DISPATCHER
from ryu.controller.handler import set_ev_cls
from ryu.ofproto import ofproto_v1_3

class TrafficSteeringController(app_manager.RyuApp):
    OFP_VERSIONS = [ofproto_v1_3.OFP_VERSION]

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.datapaths = {}
        self.logger.info("[INIT] Traffic Steering Controller initialized")

    @set_ev_cls(ofp_event.EventOFPSwitchFeatures, CONFIG_DISPATCHER)
    def switch_features_handler(self, ev):
        datapath = ev.msg.datapath
        self.datapaths[datapath.id] = datapath
        self.logger.info(f"[SWITCH CONNECTED] DPID={datapath.id}")

        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser

        # Table-miss: send unmatched packets to controller
        match = parser.OFPMatch()
        actions = [parser.OFPActionOutput(ofproto.OFPP_CONTROLLER,
                                          ofproto.OFPCML_NO_BUFFER)]
        self.add_flow(datapath, 0, match, actions)

    def add_flow(self, datapath, priority, match, actions):
        ofproto = datapath.ofproto
        parser = datapath.ofproto_parser
        inst = [parser.OFPInstructionActions(ofproto.OFPIT_APPLY_ACTIONS, actions)]
        mod = parser.OFPFlowMod(datapath=datapath,
                                priority=priority,
                                match=match,
                                instructions=inst)
        datapath.send_msg(mod)
        self.logger.info(f"[FLOW ADDED] DPID={datapath.id}, Priority={priority}, Match={match}")

    @set_ev_cls(ofp_event.EventOFPStateChange, [MAIN_DISPATCHER, DEAD_DISPATCHER])
    def state_change_handler(self, ev):
        datapath = ev.datapath
        if ev.state == DEAD_DISPATCHER and datapath.id in self.datapaths:
            self.logger.info(f"[SWITCH DISCONNECTED] DPID={datapath.id}")
            del self.datapaths[datapath.id]
```

---

## **3. Windows + VM X11 Setup for Demo**

### **Step 1: Start X Server on Windows**

* Install **VcXsrv** or **Xming**
* Run it, **“Disable access control”** checked for demo.

---

### **Step 2: Open 3 terminals**

1. **Terminal 1: Ryu Controller**

```bash
ssh -Y mininet@192.168.56.105
cd ~/sdn-traffic-steering/controller/
python3 ryu-manager traffic_steering_controller.py --verbose
```

2. **Terminal 2: Mininet Topology + xterm**

```bash
ssh -Y mininet@192.168.56.105
# Optional: if DISPLAY not auto-set
export DISPLAY=192.168.56.1:0.0
xhost +local:root
cd ~/sdn-traffic-steering/
sudo python3 topology/traffic_steering_topology.py
# Inside Mininet CLI:
mininet> xterm h1 h2 h3 h4
```

3. **Terminal 3: Optional monitoring / ping**

```bash
ssh -Y mininet@192.168.56.105
# Run any monitoring commands, e.g.
ping h1
```

---

## **4. Verification**

Inside host xterm windows:

```bash
h1$ ping -c3 h3
h2$ ping -c3 h4
h3$ ping -c3 h1
h4$ ping -c3 h2
```

* All hosts should be reachable → **0% packet loss**.

---

## **5. Demo Plan – What to Show**

| Step | Terminal | Action                           | Purpose / Explanation                          |
| ---- | -------- | -------------------------------- | ---------------------------------------------- |
| 1    | Term 1   | Start Ryu controller             | Show SDN control plane running                 |
| 2    | Term 2   | Start topology                   | Show network is created in Mininet             |
| 3    | Term 2   | `xterm h1 h2 h3 h4`              | Show traffic steering in GUI hosts             |
| 4    | Any      | Ping between hosts               | Show L2 connectivity and controller forwarding |
| 5    | Term 1   | Show Ryu logs                    | Explain table-miss, flows, packet-in events    |
| 6    | Term 2   | `sh ovs-ofctl dump-flows s1` etc | Explain flows and priorities in switches       |
| 7    | Term 3   | Run `iperf` or monitoring        | Show traffic measurement if desired            |

> This workflow is **simple, beginner-friendly**, and ensures everything works visually for your demo.

---

## ✅ **Key Notes for Capstone**

1. **Mininet** simulates your topology in software.
2. **Ryu Controller** implements traffic steering logic.
3. **xterm windows** allow each host to show real-time interaction.
4. **`xhost +local:root` or DISPLAY export** ensures GUI works with Mininet root hosts.
5. **Step-by-step verification** makes your demo smooth and easy to explain.

---

I can also make a **single copy-paste demo script** that automatically:

* Starts Ryu
* Starts Mininet
* Opens all xterms
* Pings all hosts

…so you just run **one command** for your capstone.

Do you want me to create that?
